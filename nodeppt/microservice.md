title: 微服务
speaker: 钟华
url: https://github.com/ksky521/nodePPT
transition: move
theme: moon



[slide]
# 微服务分享
<small>By：ZhongHua</small>


[slide]
## 微服务的特点
---

* 小而专注
* 高度自治


[note]

和具体技术无关, 他更多是一种方法论, 是构建更容易维护和具有更好扩展性的一种方式

小是微服务一个很明显的特征, 但不是决定性的特征

可靠应用不是说就是把单一整体分割成小片段，而是去理解各个片段的联系

需要准确的识别服务边界

微服务是一个笼统的概念, 微仅仅是这种"可扩展, 易维护, 高内聚, 小而自治"的系统的一个特点

[/note]




[slide]
## 单一庞大应用不足
---

* 逐渐变大, 几年后变成巨大怪物
* 开发团队痛苦, 敏捷开发和部署举步维艰, 任何单一开发都不可能搞懂, 团队士气走下坡
* 降低开发速度, 启动时间加长
* 复杂而巨大的单体式应用也不利于持续性开发
* 单体式应用在不同模块发生资源冲突时，扩展将会非常困难
* 可靠性降低, bug, 内存泄露将相互影响
* 单体式应用使得采用新架构和语言非常困难

[note]
比如数据都只用一种, 版本也只能一致
比如一个组件, 在一个小应用升级替换非常容易, 但是在大应用上就很难, 要避免影响所有现有功能变得非常困难
一开始你有一个很成功的关键业务应用，后来就变成了一个巨大的，无法理解的怪物。因为采用过时的，效率低的技术，使得雇佣有潜力的开发者很困难。应用无法扩展，可靠性很低，最终，敏捷性开发和部署变的无法完成
tao800_fire 升级redis

为什么admin 优化了快了, 又慢了
[/note]

[slide]
## 微服务的好处
---

* 单个服务很容易开发、理解和维护
* 技术异构性 
* 易于独立部署, AB测试，持续化部署
* 每个服务独立扩展
* 与组织结构相匹配, 属主意识明确

[note]

有的服务注重开发效率, 有的服务注重性能
nosql CAP
每个服务都可以有专门开发团队来开发。开发者可以自由选择开发技术，提供API服务; 重写重构,技术迭代变得不是很困难
发生性能问题, 难以评估
首页异常
10个人维护一个项目
[/note]

[slide]
## 微服务架构模式
---

![架构模式](http://zhongfox.github.io/assets/images/microservice/3d.png "架构模式")

[note]
水平扩展
扩展性: 基础设施不需要经常改变, 应用之间较少的依赖和耦合, 对需求敏捷响应
变的和不变的分开

伸缩性: 通过增减自身资源的规模, 实现处理能力的增减
[/note]


[slide]
## 微服务架构的不足
---

* 微服务应用是分布式系统，由此会带来固有的复杂性
* 因为数据分区, 也因为CAP理论, 微服务不得不使用最终一致性方案, 因此对开发要求更高
* 单体应用容易测试, 微服务测试复杂度提高, 需要各个微服务的stubs
* 改动的影响将波及很多应用, 不过这是面向服务架构的特点
* 服务拆分后, 服务增多, 部署难道和工作量增加

[note]
没有银弹

分布式事务提交困难
收藏/deal service 数据不一致
测试: 测试环境
需要部署很多次
服务边界难以识别, 不是最开始能区分出来

13年招商, 当时是服务拆分的一个好机会
[/note]


[slide]
## 微服务构建
---


* 根据业务边界来确定服务边界
* 如何寻找平衡, 如何取舍
* 分解技术
* 集成技术
* 注意服务与团队结构的关系

[note]
zapi_fire
收藏(坚守服务边界)
集成: 限时抢
根据服务表现, 技术类型

[/note]

[slide]
## 康威定律
---

任何组织在设计一套系统时, 所交付的设计方案在结构上都与该组织的沟通结构保持一致

[note]

一种现象

招商 商城 主站 限时抢

注重团队构成对服务划分的影响

组织的耦合度越低, 创建的系统模块化越好, 耦合也越低

远程团队无法做到细粒度的沟通

开发团队存在地理位置的差异 是一个应该对服务进行分解的很明显的信号

tao800_fire 历程

电信项目
学语言是长期的收益, 凑合着开发是短期收益, 之后是负的收益
之后团队配合需要考虑, 

[/note]


[slide]
## 微服务调用
---

* 客户端到多个微服务直接通信
* API Gateway

[slide]
## 客户端到多个微服务直接通信
---
* 每个微服务暴露的细粒度API数量的不匹配, 客户端(移动端或者PC浏览器)需要发起多个(甚至数百个)服务请求,  在公网上效率非常低, 客户端代码非常复杂
* 微服务的协议可能并不是web友好型。
* 很难重构微服务: 随着时间推移, 服务可能合并或者拆分, 如果客户端直接与微服务交互，那么这种重构就很难实施.

[note]
一个服务可能是用Thrift的RPC协议，而另一个服务可能是用AMQP消息协议。它们都不是浏览或防火墙友好的，并且最好是内部使用。应用应该在防火墙外采用类似HTTP或者WEBSocket协议


接口设计宽进严出
[/note]


[slide]
## API Gateway
---

* 封装内部系统架构, 提供API给各个客户端

* 授权, 监控, 负载均衡, 缓存, 请求分片, 请求转发,  协议转换, 管理, 静态响应处理


[note]
API Gateway可以提供给客户端一个定制化的API, API Gateway通过调用多个服务来处理这一个请求并返回结果

涉及: 请求转发, 合成和协议转换(在web协议与内部使用的非Web友好型协议间进行转换)

deal service 合成 角标 (跨团队无法完成)

接口设计宽进严出: 他不错我不错, 他错了我不错
[/note]


[slide]
## API Gateway
----

* 优点
    * 封装应用内部结构, 减少了客户端与服务器端的通信次数，也简化了客户端代码

* 缺点
    * 必须要高可用, 必须开发,部署和管理 (额外成本)
    * 可能成为系统的一个瓶颈

[note]
瓶颈不仅仅是性能, 一致性
[/note]

[slide]
## 微服务中的数据库
----

* 强调使用独立应用数据库
* 强调可扩展, 大数据, 集群


[slide]
## 关系型数据库
----

* 优势(ACID)

  * 数据持久化
  * 并发: RMDB 使用事务控制并发; 事务执行失败可以回滚
  * 集成: RMDB可以做为"共享数据集成"提供给多个应用使用, 达到数据共享; 同时RMDB有并发控制机制.
  * 标准模型: 各种RMDB大同小异

* 不足

  * 阻抗失衡
  * 集群扩展能力弱

[note]
  阻抗失衡: 开发效率
[/note]


[slide]
## 数据库在应用共享上的划分
----

* 集成数据库
* 应用程序数据库



[slide]
## Nosql
----

  * 不使用关系模型
  * 专注大数据, 集群
  * 无模式: 提高开发效率, 优化阻抗失衡
  * 适合"应用程序数据库", 不适合"集成数据库"
  * 开源
  * 影响: 混合持久化

[slide]
##  谢谢
----

问题&讨论
