---
layout: link
category : link
link: /link/2015/08/17/xljt
title: 一些心灵鸡汤, 方法论等等

---

[IT小小鸟生存指南－学习起步篇](http://wj1s.github.io/xxn-01/)

1. 工作用什么学什么；

   工作用什么，学什么，以点带面，顺势而为，将自己学的东西与工作契合，利用所有时间学习

2. 先上手后学习；

3. 无目标不学习，学到够用就停止


---

[为什么你应该尝试全栈](http://blog.zhowkev.in/2015/08/12/wei-shi-yao-ni-ying-gai-chang-shi-quan-zhan/)

在团队沟通的时候，对对方技术的了解能减少非常多的沟通成本，并带来尊重和和平

---

[小黄鸭调试法，每个程序员都要知道的](http://blog.jobbole.com/85719/)

我也有过这样的经历, 旁边的同事遇到一个问题, 百思不解, 然后拉着我给我描述这个问题的由来, 往往在问题还没有描述完, 他忽然就顿悟了: 噢, 我知道了, 原来...(某个地方做了错误的假设)..., 这个时候其实我还没有明白是什么问题, 但是问题已经解决了, 我只能微微一笑, 深藏功与名.

小黄鸭, 专注发现"我不知道我不知道"三十年

---

[The First Rule of Programming: It's Always Your Fault](http://blog.codinghorror.com/the-first-rule-of-programming-its-always-your-fault/)


---

[绩效/加薪/年终奖，虐你如初恋](https://mp.weixin.qq.com/s?__biz=MzAxMzUzNzYyNA==&mid=401470348&idx=1&sn=74a3fcffb754cf176cffa841f175abb2)

* 一个人的绩效，应该更少的与职级相关，更多地与具体工作表现和结果相关

  薪水差异已经体现了职级差别了

* 你肯定什么行为，就会强化什么行为

  所以代码行统计不能公开

 ---

[顶级程序员的 10 条最佳实践](http://36kr.com/p/207585.html)

* 你不是程序猿！

  伟大的开发者能够建构并开发应用。惊艳的开发者能够在关注业务的同时做这件事

  精通编程是一个崇高的职业目标。一旦实现了这个目标，别忘了考虑一下你自己。不要成为任何公司的奴隶或者在毫无价值的东西上浪费你的时间

* 荣誉属于过去, 理论是一回事，但实践更重要

  不断探索

* 像躲瘟疫一样避免过早优化

* 你的代码只写一次，可别人会读它千万遍

* 这是一个崇高的职业。把你的技能用到好的地方

---

[通过「刻意练习」，你才能成为顶尖的程序员](https://ruby-china.org/topics/28553)

* 如何打破无休止的加班？

  效率低 -> 无法按时完成工作 -> 加班 -> 没有时间练习 -> 效率越来越低

  要打破怪圈，有效的办法就是「刻意练习」，从此进入一个正向循环：效率高 -> 提前完成工作 -> 练习提升 -> 效率越来越高

* 别把工作当练习

  练习应当发生在工作之外

* 只有在「学习区」练习才最有成效。

  我们应当走出舒适区，多在学习区练习，将其变成舒适区；

  接触恐慌区，将其慢慢变成学习区。

* 没时间不是借口

  周末你都在做什么?

---

[程序员到底是一个什么职业？](http://36kr.com/p/5043177.html)

<http://weibo.com/ttarticle/p/show?id=2309403939907201539934>

* 创业媒体们故意模糊了创造和创业的界限，把程序员们的创造冲动偷换概念，鼓吹了太多不适合的人去创业

* 如果不是你自己开的公司，那么雇员同学，你的价值是由你对公司的贡献来决定的

* 绝大部分互联网公司的程序员职位，没有技术门槛

  人与人的价值体现在于很多非技术方面

* 工程的本质不是创造，而是去风险化

  工程是关于如何 低成本、高效率、按时按量完成既定任务的。所以判断一个工程师是否优秀，并不是他多有创意多有名气，而是看他有多稳，看他能多 GettingThingsDone，中文就是「靠谱」

* 工程的另一个要求是进度控制和质量控制

---

[从淘汰Oracle数据库的事情说起](http://www.raychase.net/3689)

* 关系型数据库不但在过去的几十年内很成功，而且成功到被乱用滥用了

* 简单劳动，甚至不简单，但是容易被模拟的劳动，还是不可逆转地慢慢地被机器和软件所替代。

  于是一大帮程序员都在喊技术至上，要做技术，这也是手工艺人谋生的基础。但是同样是技术，可不尽相同，有的也有逐渐被淘汰的趋势

* “维护”这一件事情，要么因为简单而能被机器和软件替代掉，要么因为复杂而被革命掉

---

[对一门编程语言的基本尊重](http://www.pureage.info/2016/03/27/basic-respect-to-a-programming-language.html)

* 这些人就缺少对一门编程语言的基本尊重

---

[如何评价Uber不用Node.js，而用Go语言构建地理查询服务？](https://cnodejs.org/topic/571cf4c7fa48138c41110d54)

架构的演进过程，一般如下

* 无论如何，先实现(不择手段，或者说用自己擅长的)
* 优化（一棵树上吊死）
* 服务化（东拼西凑，捉襟见肘，趋于稳定）
* 合适的技术做合适的事儿（有选择的挖坑优化）

最终还是要回归到架构的本质上去的，场景决定技术

---

[简单设计](https://codingstyle.cn/topics/185)

1. 通过所有测试（Passes its tests）

  需求最大

2. 尽可能消除重复 (Minimizes duplication)

  高内聚，低耦合，达到良好正交性的过程

3. 尽可能清晰表达 (Maximizes clarity)

  整洁代码

4. 更少代码元素 (Has fewer elements)

  尽可能降低复杂度，保持简单

  YAGNI(You Aren't Gonna Need It): 我们要着眼当下，不去为自己猜想出的未来可能性去增加系统的复杂度

5. 以上四个原则的重要程度依次降低

  其中2和3的优先级争议: 长篇累牍的大块流程代码，反而更容易理解, 要不要拆成独立模块

  * 2代表SLAP（Single Level of Abstraction Priciple）
  * 3代表(主观的)可理解性

---

[微服务到头了？？？](http://coyee.com/article/10548-the-end-of-microservices)

搭建可靠应用不是说就是把单一整体分割成小片段，而是去理解各个片段的联系

---

[消息队列设计精要](http://tech.meituan.com/mq-design.html)

什么削峰控流, 一个比喻秒杀一切: **漏斗**

