---
layout: post
categories: [blog, server]
tags : [cache, redis, nosql, distributed]
title: NoSql 精粹读书笔记
---
{% include JB/setup %}


## 为什么使用NoSql

* RMDB价值

  * 数据持久化
  * 并发: RMDB 使用事务控制并发; 事务执行失败可以回滚
  * 集成: RMDB可以做为"共享数据集成"提供给多个应用使用, 达到数据共享; 同时RMDB有并发控制机制.
  * 标准模型: 各种RMDB大同小异

* RMDB 阻抗失衡

  RMDB中的表(关系), 行(键值对的元组)无法直接表示实际内存中的数据结构, 比如嵌套记录, 列表等

  阻抗失衡要求关系和实际数据结构之间必须转译

  应对:

  * 面向对象数据库: 消失鸟
  * ORM: 轻松解决阻抗失衡, 但是"框架本身就成了问题", 查询性能下降
  * NoSql

* 数据库在应用共享上的划分

  * 集成数据库: 多应用同时读写一个数据库, 应用之间数据完整性难以保证, 完整性需要数据库来负责(RMDB有固有schema在这里是一个优势)

    这也是RMDM战胜面向对象数据库的一个原因

  * 应用程序数据库: 指定的数据库由一个应用维护, 该应用代码维护数据完整性, 数据结构对其他数据库不透明

    通过接口对外提供服务, 这是面向服务架构的特征之一, 交互数据结构更灵活, 比如使用json/xml/二进制协议

    内部数据与外部通信解耦, 数据库技术选择余地更大

* RMDB 与 集群

  RMDB 分片实现水平扩展, 但是应用程序必须控制分片, 查询, 完整性, 事务, 一致性等跨分片难以实现

  RMDB 按照单机计费

* NoSql

  * 不使用关系模型
  * 专注大数据, 集群
  * 无模式: 提高开发效率, 优化阻抗失衡
  * 适合"应用程序数据库", 不适合"集成数据库"
  * 开源
  * 影响: 混合持久化

---

## 聚合数据模型

* 数据模型: 数据库组织数据的方式

  RMDB使用关系数据模型, 每种NoSql实现各种不同的数据模型, 主要有:

  * 键值
  * 文档
  * 列族
  * 图

  其中, "键值" "文档" "列族" 都是面向聚合

* 聚合 affregate

  相关联对象作为一个整体单元来操作, 比如列表或者嵌套记录

  聚合更容易完成原子操作, 复制, 分片, 同时对应用程序更友好

  RMDM 没有聚合实体的概念, 是聚合无知的, NOSQL中图数据库也是聚合无知

  聚合规划应该更多的由**数据访问方式**决定

  聚合边界一般难以界定, 如果有多种差异比较大的访问形式, 面向聚合反而是比较困难

  因此, 如果没有一种主导的结构, 使用聚合无知可能更好

  面向聚合不支持跨聚合的ACID事务, 但是单个聚合上是可以进行原子操作的, 因此如果需要跨聚合原子操作, 需要应用程序实现, 但是使用聚合应该将大部分原子操作局限到单聚合内部

* 键值聚合: 聚合不透明, 可以存储任何数据, 基本通过key查询

* 文档聚合: 存放数据有限制, 有结构, 可以局部获取, 可以根据聚合内容创建索引, 可以根据文档内部信息进行查询

* 列聚合: TODO

---


## 数据模型详解

* 关系:

  数据模型间不可避免存在关联, 各种NoSql也以不同方式支持关系

  面向聚合的数据库不适合处理大量关系, 这种情况更应该使用关系型数据库(SQL 提供 JOIN, 但是效率会随着关系的复杂度而降低)

* 图数据库

  适合处理: 关系复杂, 数据模型简单

  数据结构: 节点(node), 边(edge)

  与RMDB比较:

  * RMDB JOIN 效率低
  * 图数据库有专门为图关系设计的查询操作, 关系遍历快: 因为在插入时花时间构建关系数据, 提满足高效的关系查询 (权衡以提供满足需求)

  与面向聚合数据库比较:

  * 图数据库重视关系
  * 图数据库通常运行在单机, 不是分布式, 支持ACID事务
  * 两者都不使用(标准)关系模型
