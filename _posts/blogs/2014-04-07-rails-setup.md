---
layout: post
categories: [blog, rails]
tags : [file]
title: Rails 加载过程
---
{% include JB/setup %}

### rails启动过程

1. 当前ruby版本的默认gemset下bin中rails

        % which rails
        /Users/zhonghua/.rvm/gems/ruby-2.0.0-p247/bin/rails

   该文件中主要

        require 'rubygems'
        version = ">= 0"

        if ARGV.first #这段原因不明
          str = ARGV.first
          str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
          if str =~ /\A_(.*)_\z/
            version = $1
            ARGV.shift
          end
        end

        #这句话把/Users/zhonghua/.rvm/gems/ruby-2.0.0-p247/gems/railties-4.0.0/bin/rails加入了$: 所以后面可以require 'rails/...'
        gem 'railties', version #TODO
        load Gem.bin_path('railties', 'rails', version) #/Users/zhonghua/.rvm/gems/ruby-2.0.0-p247/gems/railties-4.0.0/bin/rails

2. 步骤一种最后load的railties中bin中rails, 作用主要加载`rails/cli`

        git_path = File.join(File.expand_path('../../..', __FILE__), '.git')

        if File.exists?(git_path) #原因不明
          railties_path = File.expand_path('../../lib', __FILE__)
          $:.unshift(railties_path)
        end
        require "rails/cli"

3. `rails/cli`  主要执行了`Rails::AppRailsLoader.exec_app_rails`

        require 'rbconfig' #TODO
        require 'rails/app_rails_loader'

        # If we are inside a Rails application this method performs an exec and thus
        # the rest of this script is not run.
        Rails::AppRailsLoader.exec_app_rails

        require 'rails/ruby_version_check'
        Signal.trap("INT") { puts; exit(1) }

        if ARGV.first == 'plugin'
          ARGV.shift
          require 'rails/commands/plugin_new'
        else
          require 'rails/commands/application'
        end

4. `rails/app_rails_loader` 中`Rails::AppRailsLoader.exec_app_rails`

        def self.exec_app_rails
          original_cwd = Dir.pwd

          loop do #主要递归找到rails的根目录
            if exe = find_executable
              contents = File.read(exe)

              if contents =~ /(APP|ENGINE)_PATH/ #因为rails项目里地bin/rails 中有APP_PATH,所以流程到这里
                exec RUBY, exe, *ARGV #TODO exec的注释
                break # non reachable, hack to be able to stub exec in the test suite
              elsif exe.end_with?('bin/rails') && contents.include?('This file was generated by Bundler')
                $stderr.puts(BUNDLER_WARNING)
                Object.const_set(:APP_PATH, File.expand_path('config/application', Dir.pwd))
                require File.expand_path('../boot', APP_PATH)
                require 'rails/commands'
                break
              end
            end

            # If we exhaust the search there is no executable, this could be a
            # call to generate a new application, so restore the original cwd.
            Dir.chdir(original_cwd) and return if Pathname.new(Dir.pwd).root?

            # Otherwise keep moving upwards in search of a executable.
            Dir.chdir('..')
          end
        end

5. 上一步中`exec RUBY, exe, *ARGV` 将执行rails项目目录下的`bin/rails`

        APP_PATH = File.expand_path('../../config/application',  __FILE__) #这个是项目的启动文件，之后的命令如果需要启动目录就`require APP_PATH`
        require_relative '../config/boot'
        require 'rails/commands'

6. `../config/boot` rails项目的boot文件主要是加载bundle

        ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)
        require 'bundler/setup' if File.exists?(ENV['BUNDLE_GEMFILE'])

7. 步骤5中`require 'rails/commands'`

        aliases = {
          "g"  => "generate",
          "d"  => "destroy",
          "c"  => "console",
          "s"  => "server",
          "db" => "dbconsole",
          "r"  => "runner"
        }

        command = ARGV.shift # 通过判断ARGV的第一个元素，走不同的when case
        command = aliases[command] || command

   对于'generate', 'destroy', 'console', 'server' 都需要加载当前项目，所以都有`require APP_PATH`

8. `require APP_PATH` 加载项目目录下的`config/application.rb`

        require File.expand_path('../boot', __FILE__) #这里我得到的时false 因为之前加载过了
        require 'rails/all' #这里可以根据需要加载所需gem

        # Require the gems listed in Gemfile, including any gems
        # you've limited to :test, :development, or :production.
        Bundler.require(:default, Rails.env) #加载当前环境的gem
        #Rails.env在railtie/lib/rails.rb中

        module R4test
          class Application < Rails::Application
            # Settings in config/environments/* take precedence over those specified here.
            # Application configuration should go into files in config/initializers    # -- all .rb files in that directory are automatically loaded.

            # Set Time.zone default to the specified zone and make Active Record auto-convert to this zone.
            # Run "rake -D time" for a list of tasks for finding time zone names. Default is UTC.
            # config.time_zone = 'Central Time (US & Canada)'

            # The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.
            # config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]
            # config.i18n.default_locale = :de
          end
        end

9. `require 'rails/all'` 加载`railties-4.0.0/lib/rails/all.rb`

        require "rails" #这里才加载了railties-4.0.0/lib/rails文件

        %w(
          active_record
          action_controller
          action_mailer
          rails/test_unit #如果不用test unit等组件，可以在APP_PATH中改写require 'rails/all'
          sprockets
        ).each do |framework|
          begin
            require "#{framework}/railtie" #每个gem的启动文件都是其lib中gem目录中的railtie, 这个文件在各自加载gem同名文件
          rescue LoadError
          end
        end

---

### 主要命令的启动

### 'generate' 'destroy'

        require 'rails/generators'

        require APP_PATH
        Rails.application.require_environment!
        Rails.application.load_generators
        require "rails/commands/#{command}"


---

### 其他笔记

1. Rails.env

        def env
          @_env ||= ActiveSupport::StringInquirer.new(ENV["RAILS_ENV"] || ENV["RACK_ENV"] || "development")
        end

   关于 [ActiveSupport::StringInquirer](http://api.rubyonrails.org/classes/ActiveSupport/StringInquirer.html), 该字符串包装器可以让`Rails.env == 'production'`使用`Rails.env.production?`调用


2. `railties/lib/rails/application.rb`

        class << self
          #被继承是会调用 在项目中config/application.rb里, 初始化Rails.application = （ProjectName::Application）当前项目的实例
          def inherited(base)
            raise "You cannot have more than one Rails::Application" if Rails.application
            super
            Rails.application = base.instance #base就是项目中config/application.rb中定义的Application
            Rails.application.add_lib_to_load_path!
            ActiveSupport.run_load_hooks(:before_configuration, base.instance)
          end
        end

3. 关于Rails.application

        Rails.application.class.ancestors
        => [R4test::Application, Rails::Railtie::Configurable, Rails::Application, Rails::Engine, Rails::Railtie, Rails::Initializable, Object, PP::ObjectMixin, ActiveSupport::Dependencies::Loadable, JSON::Ext::Generator::GeneratorMethods::Object, Kernel, BasicObject]

---

### 疑问

1. 诸如active_record等gem的源码里，为什么没有gem_spec 等文件
---

