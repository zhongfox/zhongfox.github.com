---
layout: post
categories: [blog, ruby]
tags : [ruby]
title: Ruby 2.1: RGenGC
---
{% include JB/setup %}

要搞就搞明白点, 一知半解不如不知

---

* ruby 对象堆内存分割为slots, 每个slot存储一个RVALUE, 每个RVALUE占用40 bytes

  `GC::INTERNAL_CONSTANTS[:RVALUE_SIZE] => 40`

* ruby 2.1 GC RGenGC:  标记清除 + 分代

* 分代理论基础:

  大部分新对象存活期短, 新对象更可能包含老对象的引用(不会影响新对象成为垃圾), 而只有少部分新对象会被老对象引用(会影响新对象的回收)

  遍历新对象集会有大量垃圾可以回收, 而遍历老对象释放的内存很少

* 新对象提升为老对象: (一般情况) 在新对象标记清除中存留的对象, 提升为老对象

* 问题1: minor GC会认为 只被老对象引用的新对象 是垃圾, 因为minor GC不遍历老对象

  方案: remember set + write-barrier

* write-barrier: 当老对象写入新对象的引用时, 会触发write-barrier, 将老对象放入remember set

* remember set: 存储指向新对象的老对象集合, 以及老对象引用的shady对象

* GC 类别:

  * minor GC: 只遍历新对象集 + remember set
  * major GC: 遍历所有对象集

* 问题2:  C API 创建的对象无法有效的实现write-barrier

  方案: sunny + shady

* sunny 对象:

  实现write-barrier

  允许被提升为老对象

  shade操作: 某些C API会使sunny 对象write-barrier失效, 此时sunny 对象将变为shady, (必要的话)从老对象中去除加人remember set

* shady 对象:

  没有实现write-barrier

  不允许提升为老对象(因为老对象需要write-barrier来避免问题1)

  shady对象如果被老对象引用, 将被GC放入remember set (如何理解?)

----

## 参考资料

* <http://thorstenball.com/blog/2014/03/12/watching-understanding-ruby-2.1-garbage-collector/>
* <http://tmm1.net/ruby21-rgengc/>
