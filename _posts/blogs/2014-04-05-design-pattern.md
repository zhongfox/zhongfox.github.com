---
layout: post
categories: [blog, java]
tags : [design pattern, java]
title: 设计模式学习
---
{% include JB/setup %}

### 设计模式基础

设计模式中的关系：

1. IS-A 使用继承

2. HAS-A 使用组合

3. IMPLEMENTS 使用接口

---

### 原则

1. [Don't Repeat Yourself](id:rule_1)

2. [封装变化](id:rule_2)

   找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起

   把会变化的代码封装起来（抽象）

   结果的好处是系统中变化的部分不会影响其他部分，系统变得更有弹性

3. [多用组合，少用继承](id:rule_3)

   组合可以实现更多的可能性，能适应更多的细节，因此代码更有弹性



4. [针对接口编程，不是针对实现编程](id:ruby_4)

   接口是对继承思想中相同或者不同继承链中相似行为的再一次抽象

   针对接口编程，真正的意思是针对超类（抽象类或者接口类型）编程，延迟绑定

   要面向抽象编程，延迟面向细节编程

5. [为交互对象之间的松耦合设计而努力](id:ruby_5)

6. [类应该对扩展开放，对修改关闭](id:ruby_6)

---

### State 状态模式

<img src="/assets/images/design_pattern/state.png" />

* 定义：运行对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类

* 适用场景：Context 类中持有不同的状态，Context的某些行为随着状态的不同而不同，行为也可以改变状态

* 不好的设计：在Context的各个行为中对状态进行判断，执行不同的代码

  * 太多相似的（对状态判断）代码 [DRY](#rule_1)
  * 添加新的状态，需要修改的地方太多（每个行为中要增加一个if 判断） [对修改关闭](#ruby_6)

* 使用State模式

  * 创建State（抽象类或者接口）：对不同的状态使用一个子类代表
  * Context和State相互组合，Context持有一个State基类的引用，State也有Context的引用 [多用组合，少用继承](#rule_3)
  * Context把所有和状态相关的行为委托到State基类引用（Context类中的行为统一委托给了State类，新加状态或者修改行为状态关系都抽象到了State类）[对修改关闭](#ruby_6) 
  * 具体的State子类来实现行为，并可以在行为中修改Context的引用的State
  * 移除了容易产生问题的if语句

---

### Strategy ['strætɪdʒɪ] 策略模式

<img src="/assets/images/design_pattern/strategy.jpg" />

* 定义：定义了算法簇，分别封装，让他们可以互相替换，此模式让算法变化独立于使用算法的客户

* 使用场景：Client类的继承链中某些行为在各个子类中差异性较大（甚至或有或无），或者行为经常发生变化

* 不好的设计：在Client类中的差异性动态行为完全依赖子类去控制

  * 经常变化的代码（策略）散落到继承链中各个地方 [封装变化](#rule_2)
  * 某些子类之间相似代码太多 [DRY](#rule_1)

* 使用Strategy模式

  * 把Client类中的差异性动态行为提取为算法簇类 [封装变化](#rule_2)  算法簇类以抽象类或者接口开始
  * Client基类中声明实例变量类型为算法簇基类类型 [多用组合，少用继承](#rule_3)
  * Client基类中把相关方法都委托给算法簇基类类型实例变量 [针对接口编程，不是针对实现编程](#ruby_4)
  * Client子类实例化时可以指定想要的算法簇，并且在生命周期中可以随时改变算法簇


