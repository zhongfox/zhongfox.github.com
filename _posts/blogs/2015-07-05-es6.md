---
layout: post
categories: [blog, javascript]
tags : [nodejs, es6]
title: es6 笔记
---
{% include JB/setup %}

---

## Iterator

* 规格描述:

      interface Iterable {                     //部署了遍历器接口的数据结构规格
        [System.iterator]() : Iterator,        //需要返回迭代器
      }

      interface Iterator {                    //迭代器规格
        next(value?: any) : IterationResult,  //迭代器必须有next方法
      }

      interface IterationResult {             //迭代器返回值规格
        value: any,
        done: boolean
      }

* 遍历器接口: 支持遍历器数据结构的`System.iterator`属性, 返回遍历器接口, 是一个函数, 调用将返回一个遍历器

* 遍历器: 调用遍历器接口返回遍历器, --`for...of`

* 对于类似数组的对象（存在数值键名和length属性），部署Iterator接口，有一个简便方法

  `NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];`

* 遍历器适用的其他api:

  * 解构赋值: `let [x,y] = new Set().add('a').add('b').add('c')`
  * 扩展运算符（...）: `['a', ...arr, 'd']`
  * `yield*`
  * Array.from()
  * Map(), Set(), WeakMap(), WeakSet()
  * Promise.all(), Promise.race()

* 原生具备iterator接口的数据结构

  * 数组的entries()、keys()和values(), 返回值是迭代器
  * 字符串: `someString[Symbol.iterator]()`

  可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的

* for...of

  of 需要一个`部署了遍历器接口的数据结构`, 如:

      function Iterable(){
        var index = 0;
        var iterable = {};
        iterable[Symbol.iterator] = function () {
            var iterator = {
              next: function(){
                return {value: index++, done: false};
              }
            };
            return iterator;
        };
        return iterable;
      }

      var iterable = Iterable();

      for (var item of iterable) {
        console.log(item); //无限输出
      }

* 原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构

  * 数组

    数组是Iterable, `for(let v of arr)` 和 `for(let v of arr[Symbol.iterator]())`等价

    原生js `for (key in arr)` 获取键名, `for (value of arr)` 获取键值

---

## Generator

* 生成器函数同其他函数一样, 中如果没有显示return, 将有一个隐式`return undefined`, 因此这种生成器最后一次next将是`{ value: undefined, done: true }`

* 对于`{ value: XXX, done: true }`的next值, 不会出现在`for v in gen()`的值v里, 也就是`done: true` 的value不被遍历, 对显示和隐式的return都一样

* 生成器就是一个迭代器, 生成器也是`具备Iterator接口的数据结构`

      function* gen(){
        // some code
      }
      var g = gen();
      g[Symbol.iterator]() === g
      // true

* Generator.prototype.throw()

  * Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获

    执行流程会因为生成器在外部的throw, 而回到生成器里, 对执行流程的影响等价于next

  * 如果Generator函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获

  * Generator函数内抛出的错误，也可以被函数体外的catch捕获

    此时执行流程转交外部

    一旦Generator执行过程中抛出错误，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了

* Generator.prototype.return(somevalue)

  返回`{ value: "somevalue", done: true }`, 生成器终止

  如果生成器中有`finally` return方法会推迟到finally代码块执行完再执行 TODO

* `yield*`

  * 对外部生成器对象执行next, 会透明传递给内部`yield*`调用的其他生成器对象:

        function* inner() {
          yield '1';
          yield '2';
        }


        function* outer2() {
          yield 'open'
          yield* inner()
          yield 'close'
        }

        var gen = outer2()
        console.log(gen.next().value) // "open"
        console.log(gen.next().value) // "1"
        console.log(gen.next().value) // "2"
        console.log(gen.next().value) // "close"

  * `for of`等会递归遍历内外生成器

    `yield*`不过是for...of的一种简写形式

  * 任何数据结构只要有Iterator接口，就可以被`yield*`遍历

        let read = (function* () {
          yield 'hello';
          yield* 'hello';
        })();

        read.next().value // "hello"
        read.next().value // "h" 字符串也是可遍历对象

  * 如果被代理的Generator函数有return语句，那么就可以向代理它的Generator函数返回数据

    这点很重要

* Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法

---

## 参考资料

* <http://es6.ruanyifeng.com/#docs/generator>
